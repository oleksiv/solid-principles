# Сценарій відеоуроку: Принцип підстановки Лісков

Привіт! Сьогодні ми розберемо третю букву з SOLID — принцип підстановки Лісков. Знаю, назва звучить страшно, але насправді все дуже просто. Я покажу тобі, як цей принцип допоможе писати код, який працює передбачувано і не ламається в найнесподіваніший момент.

Після цього уроку ти точно зрозумієш, коли варто використовувати наслідування, а коли краще його уникати. І головне — твій код стане набагато надійнішим.

Отже, що ж це за принцип такий? Простими словами — якщо у тебе є клас-батько і клас-дитина, то ти маєш змогу використовувати дитину замість батька без жодних проблем. Ніби все логічно, правда? Але давай подивимось, як це працює на практиці.

Офіційне формулювання звучить так: об'єкти базового класу повинні бути замінними об'єктами підкласів без порушення коректності програми. Складно? Давай на прикладі.

Уяви, що у тебе є функція, яка працює з класом Тварина. Згідно з принципом Лісков, ця функція має працювати однаково добре з будь-яким класом, який наслідується від Тварина — чи то Собака, чи Кіт, чи Папуга. Жодних сюрпризів, жодних помилок.

Є три основні правила, які варто запам'ятати. Перше — підклас не повинен ламати роботу батьківського класу. Друге — підклас може додавати нову функціональність, але не змінювати стару. І третє — код, який працює з батьківським класом, повинен працювати і з підкласом.

А що буває, коли ми порушуємо цей принцип? Код стає непередбачуваним — ти ніколи не знаєш, чого очікувати. Доводиться писати купу додаткових перевірок типу "а це точно той клас, який мені потрібен?". Тестувати такий код — суцільне страждання. І найгірше — коли додаєш нові функції, постійно боїшся щось зламати.

Давай розглянемо класичний приклад, який здається логічним, але насправді порушує принцип Лісков. Це історія про прямокутники та квадрати.

```typescript
class Rectangle {
  protected width: number;
  protected height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  setWidth(width: number): void {
    this.width = width;
  }

  setHeight(height: number): void {
    this.height = height;
  }

  getWidth(): number {
    return this.width;
  }

  getHeight(): number {
    return this.height;
  }

  getArea(): number {
    return this.width * this.height;
  }
}
```

Ось у нас є клас Rectangle — звичайний прямокутник. У нього є ширина, висота, методи для їх встановлення та обчислення площі. Все просто і зрозуміло.

Тепер давай створимо квадрат. Логічно ж — квадрат це особливий вид прямокутника, де всі сторони рівні. Тому успадкуємо його від Rectangle.

```typescript
class Square extends Rectangle {
  constructor(side: number) {
    super(side, side);
  }

  setWidth(width: number): void {
    this.width = width;
    this.height = width;
  }

  setHeight(height: number): void {
    this.width = height;
    this.height = height;
  }
}
```

Бачиш, що ми зробили? У квадрата при зміні ширини автоматично змінюється і висота. І навпаки. Бо квадрат же має мати однакові сторони! Здається, все логічно. Але давай подивимось, що станеться, коли ми спробуємо використати квадрат замість прямокутника.

```typescript
function resizeRectangle(rectangle: Rectangle): void {
  rectangle.setWidth(5);
  rectangle.setHeight(4);

  console.log(`Очікувана площа: 20, Реальна площа: ${rectangle.getArea()}`);
}

const rectangle = new Rectangle(2, 3);
const square = new Square(3);

resizeRectangle(rectangle);
resizeRectangle(square);
```

Запускаємо код. З прямокутником все працює — встановили ширину 5, висоту 4, отримали площу 20. А от з квадратом... Очікували площу 20, а отримали 16! Чому? Бо коли ми встановили висоту 4, квадрат автоматично змінив і ширину на 4. Адже він має зберігати однакові сторони.

Ось тобі і проблема. Функція resizeRectangle очікувала, що може встановити ширину і висоту незалежно одна від одної. А квадрат змінив правила гри. Результат — непередбачувана поведінка коду.

Висновок простий — хоча математично квадрат є прямокутником, в програмуванні їх поведінка різна. І це порушує принцип Лісков.

Як же правильно вирішити цю проблему? Давай розділимо відповідальності та використаємо інтерфейси.

```typescript
interface Shape {
  getArea(): number;
}

class Rectangle implements Shape {
  protected width: number;
  protected height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  setWidth(width: number): void {
    this.width = width;
  }

  setHeight(height: number): void {
    this.height = height;
  }

  getWidth(): number {
    return this.width;
  }

  getHeight(): number {
    return this.height;
  }

  getArea(): number {
    return this.width * this.height;
  }
}
```

Тепер у нас є інтерфейс Shape, який говорить — всі фігури можуть обчислювати площу. Rectangle реалізує цей інтерфейс і має свою логіку роботи з шириною та висотою.

```typescript
class Square implements Shape {
  private side: number;

  constructor(side: number) {
    this.side = side;
  }

  setSide(side: number): void {
    this.side = side;
  }

  getSide(): number {
    return this.side;
  }

  getArea(): number {
    return this.side * this.side;
  }
}
```

А Square теж реалізує Shape, але має свою логіку — він працює тільки з однією стороною. Ніякого наслідування, ніяких сюрпризів.

```typescript
function calculateArea(shape: Shape): void {
  console.log(`Площа фігури: ${shape.getArea()}`);
}

const rectangle = new Rectangle(5, 4);
const square = new Square(3);

calculateArea(rectangle);
calculateArea(square);
```

Тепер функція calculateArea працює з будь-якою фігурою через інтерфейс Shape. І прямокутник, і квадрат обчислюють площу правильно, кожен за своїми правилами. Код став передбачуваним і безпечним.

Що ми змінили? По-перше, прибрали наслідування — Square більше не успадковується від Rectangle. По-друге, створили спільний інтерфейс, який визначає, що можуть робити всі фігури. По-третє, кожен клас тепер має свою логіку — Rectangle може змінювати ширину і висоту незалежно, а Square працює тільки з однією стороною. Результат — передбачувана поведінка коду.

Давай розглянемо ще один приклад, де здається логічно використати наслідування, але це знову приводить до проблем. Це історія про птахів та їх здатність літати.

```typescript
class Bird {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  fly(): void {
    console.log(`${this.name} літає в небі`);
  }

  makeSound(): void {
    console.log(`${this.name} видає звук`);
  }
}
```

Ось базовий клас Bird. Всі птахи мають ім'я, вміють літати та видавати звуки. Поки що все добре.

```typescript
class Eagle extends Bird {
  constructor() {
    super("Орел");
  }

  fly(): void {
    console.log(`${this.name} ширяє високо над горами`);
  }

  makeSound(): void {
    console.log(`${this.name} кричить пронизливо`);
  }
}
```

Орел успадковується від Bird — все чудово працює. Орел може літати, видавати звуки. Жодних проблем.

```typescript
class Penguin extends Bird {
  constructor() {
    super("Пінгвін");
  }

  fly(): void {
    throw new Error("Пінгвіни не можуть літати!");
  }

  makeSound(): void {
    console.log(`${this.name} видає звуки пінгвіна`);
  }

  swim(): void {
    console.log(`${this.name} грайливо плаває під водою`);
  }
}
```

А тепер проблема. Пінгвін теж птах, але він не літає! Що робити? Ми змушені кидати помилку в методі fly. І ще додали метод swim, бо пінгвіни вміють плавати.

```typescript
function makeBirdFly(bird: Bird): void {
  try {
    bird.fly();
  } catch (error) {
    console.log(`Помилка: ${error.message}`);
  }
}

const eagle = new Eagle();
const penguin = new Penguin();

makeBirdFly(eagle);
makeBirdFly(penguin);
```

Дивись, що відбувається. Функція makeBirdFly очікує, що будь-який птах може літати. З орлом все добре. А от пінгвін кидає помилку! Тепер нам доводиться обгортати код в try-catch, обробляти винятки. Код став складнішим і менш надійним.

Проблема очевидна — пінгвін порушує контракт базового класу Bird. Якщо всі птахи успадковуються від Bird, то всі повинні вміти літати. Але це не так у реальному світі!

Давай виправимо це за допомогою інтерфейсів.

```typescript
interface Animal {
  name: string;
  makeSound(): void;
}

interface Flyable {
  fly(): void;
}

interface Swimmable {
  swim(): void;
}
```

Тепер у нас є три інтерфейси. Animal — для всіх тварин, які мають ім'я та видають звуки. Flyable — для тих, хто літає. Swimmable — для тих, хто плаває.

```typescript
class Eagle implements Animal, Flyable {
  name: string = "Орел";

  fly(): void {
    console.log(`${this.name} ширяє високо над горами`);
  }

  makeSound(): void {
    console.log(`${this.name} кричить пронизливо`);
  }
}
```

Орел реалізує Animal та Flyable. Він тварина, яка літає.

```typescript
class Penguin implements Animal, Swimmable {
  name: string = "Пінгвін";

  swim(): void {
    console.log(`${this.name} грайливо плаває під водою`);
  }

  makeSound(): void {
    console.log(`${this.name} видає звуки пінгвіна`);
  }
}
```

Пінгвін реалізує Animal та Swimmable. Він тварина, яка плаває. Ніякого методу fly, ніяких помилок!

```typescript
class Duck implements Animal, Flyable, Swimmable {
  name: string = "Качка";

  fly(): void {
    console.log(`${this.name} літає над ставком`);
  }

  swim(): void {
    console.log(`${this.name} плаває на поверхні`);
  }

  makeSound(): void {
    console.log(`${this.name} крякає`);
  }
}
```

А качка реалізує всі три інтерфейси — вона і тварина, і літає, і плаває. Гнучко, правда?

```typescript
function makeAnimalSound(animal: Animal): void {
  animal.makeSound();
}

function makeFlyableThingFly(flyable: Flyable): void {
  flyable.fly();
}

const eagle = new Eagle();
const penguin = new Penguin();
const duck = new Duck();

makeAnimalSound(eagle);
makeAnimalSound(penguin);
makeAnimalSound(duck);

makeFlyableThingFly(eagle);
makeFlyableThingFly(duck);
```

Тепер дивись, як елегантно все працює. Функція makeAnimalSound працює з усіма тваринами — і орлом, і пінгвіном, і качкою. А функція makeFlyableThingFly працює тільки з тими, хто літає — орлом та качкою. Спробуй передати туди пінгвіна — отримаєш помилку компіляції! TypeScript просто не дозволить тобі це зробити.

Чому це краще? По-перше, кожна тварина реалізує тільки те, що вона справді вміє. По-друге, компілятор захищає нас від помилок — неможливо випадково передати пінгвіна до функції для літаючих тварин. По-третє, код стає чіткішим — одразу зрозуміло, що качка може і літати, і плавати. І нарешті, легко додавати нових тварин — просто реалізуй потрібні інтерфейси.

Давай підсумуємо, що спільного в обох прикладах. В обох випадках ми намагалися використати неправильне наслідування — змушували підкласи поводитися як батьківські класи, але вони не могли. Це порушувало очікування — функції, які працювали з батьківським класом, ламалися з підкласами. І в результаті доводилося писати додаткові перевірки, try-catch блоки, умовну логіку.

Принцип Лісков робить код кращим через передбачуваність — ти знаєш, що всі реалізації інтерфейсу працюють однаково. Код стає простішим — менше умовної логіки та перевірок типів. З'являється безпека — компілятор TypeScript допомагає уникнути помилок. І головне — гнучкість. Легко додавати нові класи без зміни існуючого коду.

Запам'ятай три золотих правила. Перше — краще композиція, ніж наслідування. Часто краще "мати" об'єкт, ніж "бути" ним. Друге — інтерфейси визначають можливості. Вони чітко показують, що клас може робити. І третє — завжди думай про заміну. Чи можна підклас використовувати замість батьківського без проблем?

Давай я поясню принцип Лісков через просту аналогію. Уяви пульт від телевізора. У тебе є кнопка "включити". Незалежно від того, який це телевізор — Samsung, LG чи Sony — кнопка "включити" повинна включати телевізор. Якби пульт від одного телевізора замість включення почав грати музику, це було б порушенням принципу підстановки для пультів.

Так само в коді — якщо твій клас обіцяє щось робити через інтерфейс або наслідування, він повинен це робити передбачувано, як очікує код, що його використовує.

Отже, головні ідеї принципу Лісков. Підкласи повинні бути справжніми замінниками батьківських класів. Якщо щось не може замінити батьківський клас — не використовуй наслідування. Інтерфейси часто краще за наслідування для визначення спільної поведінки. І найголовніше — код повинен працювати передбачувано з будь-якою реалізацією.

Що робити далі? Подивись на свій код і знайди місця з наслідуванням. Постав собі три питання. Чи можу я замінити батьківський клас на підклас без проблем? Чи не доводиться мені писати додаткові перевірки для різних підкласів? Чи всі методи батьківського класу має сенс використовувати в підкласі?

Якщо відповідь на останні два питання "так" — можливо, варто переглянути дизайн і використати інтерфейси замість наслідування.

На цьому все! У наступному уроці ми вивчимо четвертий принцип SOLID — Interface Segregation Principle. Він допоможе створювати зручні інтерфейси, які не змушують класи реалізовувати зайве. До зустрічі!
