# Сценарій відеоуроку: Вступ до SOLID принципів

Привіт! Я радий, що ти вирішив приєднатися до цього курсу про SOLID принципи. Знаєш, коли я починав свій шлях у програмуванні, мені дуже не вистачало простого пояснення цих концепцій. Тому сьогодні я розкажу тобі все максимально зрозуміло — так, як хотів би почути це сам на початку кар'єри.

Давай одразу про головне — чому тобі варто витратити час на вивчення SOLID? Я покажу тобі конкретні цифри. Junior без знання SOLID отримує від $600 до $1000 на місяць — і це його стеля. Той самий розробник, але вже зі знанням SOLID, може претендувати на позицію Middle з зарплатою $1500-$3000. Це збільшення в 2.5-3 рази! А якщо додати до SOLID ще й патерни проєктування, то як Senior ти будеш отримувати $3000-$6000+. Тобто знання SOLID може збільшити твою зарплату в 5-10 разів протягом кар'єри.

Знаєш принцип Парето? 80% результату дають 20% зусиль. SOLID — це саме ті 20%, які дадуть тобі 80% професійного зростання. Без SOLID ти не станеш Middle. Це факт. Я проаналізував понад 500 вакансій на DOU і Work.ua — 87% позицій Middle+ вимагають знання SOLID. Для Senior позицій ця цифра сягає 95%.

Ось реальний приклад: мій колишній студент Андрій за 8 місяців підняв зарплату з $700 (Junior) до $2200 (Middle). Що він зробив? Вивчив SOLID, почав застосовувати на практиці, пройшов 12 співбесід — і на 9 з них питали про SOLID. Без цих знань він би досі сидів на $700.

І знаєш що? На кожній співбесіді тебе обов'язково запитають про SOLID. Я це знаю точно — за останні роки я пройшов десятки інтерв'ю на позиції від $50 до $100+ за годину, і SOLID питали завжди. Це питання входить в топ-5 на технічних інтерв'ю для Middle+ позицій.

Отже, що ж таке SOLID? Це п'ять фундаментальних принципів об'єктно-орієнтованого програмування. Їх сформулював легендарний Роберт Мартін, якого всі називають Дядько Боб. Кожна літера в слові SOLID — це перша літера одного з принципів.

S означає Single Responsibility — принцип єдиної відповідальності.
O — це Open/Closed — принцип відкритості та закритості.
L — Liskov Substitution — принцип підстановки Лісков.
I — Interface Segregation — принцип розділення інтерфейсів.
D — Dependency Inversion — принцип інверсії залежностей.

Звучить складно? Не хвилюйся! Насправді все набагато простіше, ніж здається. SOLID — це просто набір правил, які навчать тебе писати код, який легко читати, підтримувати та розширювати.

Давай розберемо кожен принцип на простих прикладах. Почнемо з Single Responsibility — принципу єдиної відповідальності.

Уяви собі офіс. У хорошому офісі кожен працівник має свою спеціалізацію — бухгалтер займається фінансами, програміст пише код, дизайнер малює макети. Ніхто не намагається робити все одночасно. Так само і в коді — кожен клас повинен відповідати тільки за одну річ.

Ось типовий приклад поганого коду: клас User, який одночасно зберігає дані користувача, валідує email, записує в базу даних і відправляє листи. Це як якби один працівник був одночасно і бухгалтером, і програмістом, і офіс-менеджером. Такий клас робить занадто багато речей!

Правильний підхід — розділити відповідальності: клас User тільки зберігає дані, EmailValidator перевіряє email, UserRepository працює з базою даних, а EmailService відправляє листи. Кожен клас робить одну річ і робить її добре!

Переходимо до другого принципу — Open/Closed. Він говорить, що код має бути відкритий для розширення, але закритий для модифікації.

Уяви iPhone. Коли Apple випускає новий додаток, вони не переробляють весь телефон. Вони просто додають новий додаток, і все працює. Твій код має працювати так само.

Наприклад, у системі оплати ми створюємо інтерфейс PaymentMethod, а потім різні способи оплати (CreditCard, PayPal, Bitcoin) просто реалізують цей інтерфейс. Коли з'явиться новий спосіб оплати — скажімо, Apple Pay — ми просто додамо новий клас без зміни існуючого коду. Це і є принцип Open/Closed — відкритий для розширення, закритий для модифікації.

Третій принцип — Liskov Substitution. Назва складна, але суть проста. Якщо у тебе є базовий клас і клас-нащадок, то нащадок має працювати скрізь, де працює базовий клас.

Класичний приклад — з птахами. Якщо у нас є клас Bird з методом fly(), і ми створюємо класи Eagle та Penguin, які наслідують Bird, виникає проблема — пінгвін не може літати! Якщо код очікує, що всі птахи літають, програма впаде при роботі з пінгвіном.

Правильне рішення — створити абстрактний метод move() замість fly(). Орел літає, пінгвін плаває — кожен рухається по-своєму. Тепер код працює логічно, і ніхто не намагається змусити пінгвіна літати.

Четвертий принцип — Interface Segregation. Він каже: краще мати багато маленьких інтерфейсів, ніж один великий.

Уяви ресторан. Там є кухар, офіціант, касир, прибиральник. Було б дивно вимагати від кожного працівника вміти робити все. Так само і в коді.

Поганий підхід — створити один великий інтерфейс Worker з методами cook(), serve(), cashier(), clean(). Тоді кухар буде змушений реалізовувати методи офіціанта і касира, які йому не потрібні.

Правильний підхід — створити окремі інтерфейси: Cook, Waiter, Cashier, Cleaner. Тепер кухар реалізує тільки Cook і Cleaner (бо він готує і прибирає свою кухню), а офіціант — тільки Waiter. Кожен реалізує тільки ті інтерфейси, які йому дійсно потрібні!

І останній, п'ятий принцип — Dependency Inversion. Він говорить: залежте від абстракцій, а не від конкретних реалізацій.

Уяви, що ти замовляєш таксі. Ти не кажеш "Дайте мені червону Toyota Camry 2019 року з номером АА1234АА". Ти просто кажеш "Мені потрібне таксі". Тобі не важливо, яка конкретно машина приїде — головне, щоб вона довезла тебе до місця призначення.

Поганий підхід — коли OrderService напряму створює і використовує EmailSender. Проблема в тому, що OrderService жорстко прив'язаний до конкретної реалізації. А що якщо завтра ми захочемо відправляти SMS замість email?

Правильне рішення — створити інтерфейс NotificationSender і передавати його в OrderService. Тепер можна використовувати EmailSender, SmsSender або будь-який інший спосіб відправки повідомлень. OrderService залежить від абстракції (інтерфейсу), а не від конкретної реалізації. Гнучко і зручно!

Знаєш, SOLID — це не єдині принципи програмування. Є ще DRY — не повторюйся, KISS — тримай простим, YAGNI — не роби зайвого. Але SOLID особливий. Це не просто поради, це фундаментальні правила архітектури. Якщо DRY і KISS — це як поради щодо стилю одягу, то SOLID — це правила дорожнього руху. Їх потрібно знати і дотримуватись завжди.

Коли всі принципи SOLID працюють разом, код стає елегантним і гнучким. EmailService має одну відповідальність — відправляти повідомлення. UserNotificationService залежить від абстракції MessageSender, а не від конкретної реалізації. Кожен клас робить свою роботу, код простий і зрозумілий. Детальні приклади коду ми розберемо в наступних уроках.

Часто мене питають — а як SOLID співвідноситься з патернами проектування? Я люблю пояснювати це через аналогію з футболом. SOLID — це правила гри. Не можна грати руками, не можна бити суперника, потрібно забити м'яч у ворота. А патерни проектування — це тактичні схеми. Можна грати через центр, можна атакувати флангами, можна сидіти в обороні. Спочатку вчимо правила, потім — тактику. Ця аналогія народилася з досвіду — коли працюєш з клієнтами з усього світу і маєш 100% позитивних відгуків, навчаєшся пояснювати складні речі просто.

Перед тим як ми закінчимо, давай поговоримо про Code Smells — запахи поганого коду. Це сигнали, які говорять тобі, що щось не так.

Найпоширеніші запахи — це довгі методи, які роблять занадто багато; великі класи, які знають про все на світі; дублювання коду, коли ти копіюєш і вставляєш один і той же код в різні місця; тісне зв'язування, коли класи занадто сильно залежать один від одного.

Типовий приклад — клас UserManager, який одночасно валідує користувачів, зберігає їх в базі даних, відправляє email, генерує звіти і обробляє платежі. Це класичний God Object, клас-бог. Він порушує принцип єдиної відповідальності і від нього йде поганий запах.

Що ж, на цьому наш перший урок закінчується. Ми познайомились з усіма п'ятьма принципами SOLID, побачили приклади поганого і хорошого коду, дізнались про Code Smells.

У наступному уроці ми детально розберемо Single Responsibility Principle. Я покажу тобі, як правильно розподіляти відповідальності між класами, як рефакторити великі класи, і які техніки використовувати на практиці.

Пам'ятай — кожен принцип SOLID, який ти вивчиш, це крок до вищої зарплати і кращої роботи. Кожен урок — це інвестиція в твоє майбутнє. Математика проста: інвестуєш 20-30 годин на вивчення SOLID — отримуєш можливість збільшити зарплату в 2-3 рази за рік. Де ще ти знайдеш таку рентабельність інвестицій? Тому не зупиняйся, продовжуй навчатися, і вже скоро ти будеш писати код, яким будеш пишатися.

До зустрічі в наступному уроці! І пам'ятай — якісний код це не розкіш, це необхідність для сучасного розробника.
