# Interface Segregation Principle — Принцип розділення інтерфейсів

Привіт! Сьогодні ми з тобою розберемо четвертий принцип SOLID — Interface Segregation Principle, або українською — принцип розділення інтерфейсів. Знаю, назва звучить складно, але насправді ідея дуже проста і корисна. Після цього уроку ти зможеш писати код, який набагато легше розуміти і підтримувати.

Отже, про що цей принцип? Уяви, що у тебе є пульт від телевізора з сотнею кнопок. Але реально ти використовуєш тільки п'ять з них — включити, вимкнути, гучність і перемикання каналів. Решта кнопок просто заважають і плутають. Було б набагато зручніше мати кілька маленьких пультів — один для звуку, інший для каналів, третій для налаштувань. Кожен відповідає за свою конкретну функцію.

Ось саме про це і говорить принцип розділення інтерфейсів — не змушуй класи залежати від методів, які вони не використовують. Краще створити кілька маленьких, конкретних інтерфейсів, ніж один великий з купою методів.

Давай одразу подивимось на прикладі, як це виглядає в коді. Уяви, що ми створюємо систему для різних типів принтерів. Ось типова помилка, яку роблять початківці:

```typescript
interface AllInOnePrinter {
  print(document: string): void;
  scan(document: string): string;
  fax(document: string, number: string): void;
  photocopy(document: string): string;
}

class SimplePrinter implements AllInOnePrinter {
  print(document: string): void {
    console.log(`Друкую: ${document}`);
  }

  scan(document: string): string {
    throw new Error("Цей принтер не може сканувати!");
  }

  fax(document: string, number: string): void {
    throw new Error("Цей принтер не може відправляти факс!");
  }

  photocopy(document: string): string {
    throw new Error("Цей принтер не може копіювати!");
  }
}
```

Бачиш проблему? Наш простий принтер, який вміє тільки друкувати, змушений реалізовувати купу методів, які йому взагалі не потрібні. І що ми робимо? Кидаємо помилки! Це жахливо. По-перше, код стає заплутаним. По-друге, якщо хтось випадково викличе метод сканування на простому принтері, програма впаде з помилкою. По-третє, якщо ми додамо в інтерфейс новий метод, всі наші класи одразу перестануть компілюватись.

Тепер давай виправимо цю ситуацію правильно. Замість одного великого інтерфейсу, створимо кілька маленьких:

```typescript
interface Printable {
  print(document: string): void;
}

interface Scannable {
  scan(document: string): string;
}

interface Faxable {
  fax(document: string, number: string): void;
}

interface Photocopiable {
  photocopy(document: string): string;
}
```

Тепер кожен інтерфейс відповідає за одну конкретну функцію. Це як конструктор LEGO — бери тільки ті деталі, які тобі потрібні. Давай подивимось, як тепер виглядатимуть наші принтери:

```typescript
class SimplePrinter implements Printable {
  print(document: string): void {
    console.log(`Друкую: ${document}`);
  }
}

class MultiFunctionPrinter implements Printable, Scannable, Faxable {
  print(document: string): void {
    console.log(`Друкую: ${document}`);
  }

  scan(document: string): string {
    console.log(`Сканую: ${document}`);
    return `Скановані дані з ${document}`;
  }

  fax(document: string, number: string): void {
    console.log(`Відправляю факс ${document} на номер ${number}`);
  }
}
```

Дивись, як елегантно! Простий принтер реалізує тільки інтерфейс Printable — жодних зайвих методів, жодних винятків. А багатофункціональний принтер може поєднувати кілька інтерфейсів — Printable, Scannable і Faxable. Кожен клас бере тільки те, що йому реально потрібно.

Давай протестуємо наш код і побачимо, як це працює на практиці:

```typescript
const simplePrinter = new SimplePrinter();
const multiPrinter = new MultiFunctionPrinter();

simplePrinter.print("Важливий документ");

multiPrinter.print("Звіт");
multiPrinter.scan("Документ");
multiPrinter.fax("Контракт", "+380501234567");
```

Коли ми викликаємо методи, все працює як годинник. Простий принтер друкує, багатофункціональний робить все, що вміє. А тепер найцікавіше — спробуй викликати метод сканування на простому принтері. TypeScript одразу покаже помилку компіляції! Він просто не дасть тобі написати такий код. Це набагато краще, ніж отримати помилку під час виконання програми.

Тепер давай розглянемо ще один приклад, щоб закріпити розуміння. Уяви, що ми створюємо систему управління працівниками в компанії. Ось типова помилка:

```typescript
interface Worker {
  work(): void;
  eat(): void;
  manageTeam(): void;
  fireEmployee(id: string): void;
  approveVacation(id: string): void;
}

class RegularEmployee implements Worker {
  work(): void {
    console.log("Виконую свою роботу");
  }

  eat(): void {
    console.log("Йду на обід");
  }

  manageTeam(): void {
    throw new Error("Я не можу управляти командою!");
  }

  fireEmployee(id: string): void {
    throw new Error("Я не можу звільняти співробітників!");
  }

  approveVacation(id: string): void {
    throw new Error("Я не можу схвалювати відпустки!");
  }
}
```

Знову та сама проблема! Звичайний працівник змушений реалізовувати методи менеджера, які йому взагалі не потрібні. Це як давати касиру в супермаркеті доступ до банківських рахунків компанії — безглуздо і небезпечно.

Давай виправимо це правильно:

```typescript
interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

interface Manageable {
  manageTeam(): void;
  fireEmployee(id: string): void;
  approveVacation(id: string): void;
}
```

Тепер у нас є три чітких інтерфейси. Кожен відповідає за свою роль. Давай створимо наші класи:

```typescript
class RegularEmployee implements Workable, Eatable {
  work(): void {
    console.log("Виконую свою роботу");
  }

  eat(): void {
    console.log("Йду на обід");
  }
}

class Manager implements Workable, Eatable, Manageable {
  work(): void {
    console.log("Планую роботу команди");
  }

  eat(): void {
    console.log("Йду на обід");
  }

  manageTeam(): void {
    console.log("Управляю командою");
  }

  fireEmployee(id: string): void {
    console.log(`Звільняю працівника ${id}`);
  }

  approveVacation(id: string): void {
    console.log(`Схвалюю відпустку для ${id}`);
  }
}
```

Бачиш різницю? Звичайний працівник реалізує тільки Workable і Eatable — він може працювати і ходити на обід. Менеджер додатково реалізує Manageable — він може управляти командою, звільняти людей і схвалювати відпустки. Кожен має рівно ті можливості, які йому потрібні для роботи.

Давай протестуємо:

```typescript
const regularEmployee = new RegularEmployee();
const manager = new Manager();

regularEmployee.work();
regularEmployee.eat();

manager.work();
manager.eat();
manager.manageTeam();
manager.fireEmployee("123");
manager.approveVacation("456");
```

Все працює чудово! І знову, якщо ти спробуєш викликати метод manageTeam на звичайному працівнику, TypeScript одразу покаже помилку. Це захищає твій код від дурних помилок ще на етапі написання.

Тепер давай підсумуємо, що спільного в обох прикладах. По-перше, в обох випадках ми мали великий, товстий інтерфейс, який змішував різні відповідальності. По-друге, класи були змушені реалізовувати методи, які їм не потрібні, і кидати винятки. По-третє, після розділення код став набагато чистішим і логічнішим.

Як цей принцип допомагає тобі вже сьогодні? Перше — простіше тестування. Ти можеш тестувати кожну функцію окремо, не переживаючи про зайві залежності. Друге — код легше розуміти. Подивившись на клас, одразу зрозуміло, що він може робити. Третє — гнучкість. Ти можеш легко додавати нові типи принтерів чи працівників, просто комбінуючи потрібні інтерфейси. І четверте — менше помилок. Немає зайвих методів, які можуть кинути виняток.

Запам'ятай головну ідею — роби інтерфейси маленькими і конкретними. Кожен клас повинен знати тільки про ті методи, які він реально використовує. Це як набір інструментів — замість одного величезного швейцарського ножа з сотнею функцій, краще мати окремо молоток, викрутку і пилку. Кожен інструмент робить свою справу найкраще.

Практична порада на завершення. Коли створюєш інтерфейс і думаєш "а що якщо деякі класи не будуть використовувати цей метод?" — це червоний прапорець. Зупинись і подумай, чи не варто розділити цей інтерфейс на менші частини. Повір, твоє майбутнє я скаже тобі спасибі!

Спробуй зараз подивитися на свій старий код. Гарантую, ти знайдеш там товсті інтерфейси, які можна розділити. Це чудова практика для закріплення матеріалу.

На цьому все! Ми розібрали четвертий принцип SOLID — Interface Segregation Principle. Наступного разу чекає на нас останній, але не менш важливий принцип — Dependency Inversion. До зустрічі!
