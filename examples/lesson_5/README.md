# Lesson 5: Interface Segregation Principle (ISP)

## Принцип розділення інтерфейсів

Цей урок демонструє четвертий принцип SOLID — Interface Segregation Principle. Головна ідея: **не змушуй класи залежати від методів, які вони не використовують**.

## Структура файлів

### Приклад 1: Система принтерів

-   **01-printer-violation.ts** - Порушення ISP: великий інтерфейс `AllInOnePrinter` змушує `SimplePrinter` реалізовувати методи, які йому не потрібні
-   **02-printer-refactored.ts** - Правильна реалізація: розділення на маленькі інтерфейси (`Printable`, `Scannable`, `Faxable`, `Photocopiable`)
-   **03-printer-usage.ts** - Приклад використання рефакторених класів

### Приклад 2: Система працівників

-   **04-employee-violation.ts** - Порушення ISP: інтерфейс `Worker` змішує ролі звичайного працівника та менеджера
-   **05-employee-refactored.ts** - Правильна реалізація: розділення на `Workable`, `Eatable`, `Manageable`
-   **06-employee-usage.ts** - Приклад використання рефакторених класів

## Ключові переваги ISP

1. **Простіше тестування** - можна тестувати кожну функцію окремо
2. **Легше розуміти код** - одразу зрозуміло, що може робити клас
3. **Гнучкість** - легко додавати нові типи, комбінуючи потрібні інтерфейси
4. **Менше помилок** - немає зайвих методів, які можуть кинути виняток
5. **Безпека типів** - TypeScript не дасть викликати неіснуючі методи

## Як запустити приклади

```bash
# Встановити TypeScript (якщо не встановлений)
npm install -g typescript

# Компілювати та запустити приклад
tsc 03-printer-usage.ts && node 03-printer-usage.js
tsc 06-employee-usage.ts && node 06-employee-usage.js
```

## Правило великого пальця

Коли створюєш інтерфейс і думаєш "а що якщо деякі класи не будуть використовувати цей метод?" — це червоний прапорець. Зупинись і подумай, чи не варто розділити цей інтерфейс на менші частини.
